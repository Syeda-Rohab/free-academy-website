
============================================================
   NEXT.JS BASIC COURSE - COMPLETE TRAINING
============================================================


============================================================
CHAPTER 1: SETUP
============================================================

1.1 Next.js Development Setup:
   - Node.js: Version 18.17 or later required
   - Text Editor: VS Code (Recommended)
   - Package Manager: npm, yarn, pnpm, or bun

1.2 Installation Methods:
   
   a) Create Next App (Recommended):
      npx create-next-app@latest my-app
      cd my-app
      npm run dev

   b) Manual Setup:
      npm install next react react-dom

1.3 Project Creation Step-by-Step:
   
   Step 1: npx create-next-app@latest next-app
   Step 2: Choose options:
      - TypeScript: Yes
      - ESLint: Yes
      - Tailwind CSS: Yes
      - App Router: Yes
      - src directory: Optional
      - Import alias: @/*

   Step 3: cd next-app
   Step 4: npm run dev
   Step 5: Open http://localhost:3000

1.4 Your First Next.js App:
   - Default page.tsx already created
   - Hot reload enabled
   - Ready to code!

✓ Setup Complete - Ready to code Next.js!

============================================================
CHAPTER 2: INTRODUCTION TO NEXT.JS
============================================================

2.1 Next.js Ki Definition:
   Next.js ek React framework hai jo production-ready features deta hai.
   Ye server-side rendering, static site generation, aur routing provide karta hai.

2.2 Next.js Kyun Zaroori Hai?
   ─────────────────────────────
   1. SEO Friendly - Server-side rendering se
   2. Fast Performance - Automatic optimization
   3. File-based Routing - Automatic pages
   4. API Routes - Backend bhi bana sakte hain
   5. Image Optimization - Built-in image component
   6. CSS Support - Multiple styling options
   7. TypeScript Built-in - Type safety
   8. Production Ready - Zero config deployment

2.3 Next.js Ka Role:
   ────────────────────
   • Full-stack web applications banana
   • E-commerce websites banana
   • Blogs aur content sites banana
   • Dashboards aur admin panels banana
   • SaaS applications banana
   • Portfolio websites banana
   • Real-time applications banana

2.4 Next.js History:
   - 2016: Vercel (pehle Zeit) ne banaya
   - 2017: Next.js 1.0 release
   - 2020: Next.js 10 - Major update
   - 2022: Next.js 13 - App Router introduce hua
   - 2024: Next.js 15 - Latest stable version
   - 2026: Industry standard ban gaya!

2.5 React vs Next.js:
   React: Library (sirf UI)
   Next.js: Framework (Complete solution)
   
   React mein manually karna padta hai:
   - Routing setup
   - SSR configuration
   - Build optimization
   
   Next.js mein sab built-in hai!

✓ Next.js is the React Framework for Production!

============================================================
CHAPTER 3: PROJECT STRUCTURE (app/ directory, page.tsx)
============================================================

3.1 Next.js Project Structure:
   
   my-app/
   ├── app/              # App Router (main directory)
   │   ├── layout.tsx    # Root layout
   │   ├── page.tsx      # Home page
   │   ├── globals.css   # Global styles
   │   └── favicon.ico   # Site icon
   ├── public/           # Static files
   ├── package.json      # Dependencies
   ├── next.config.mjs   # Next.js config
   ├── tailwind.config.ts # Tailwind config
   └── tsconfig.json     # TypeScript config

3.2 app/ Directory (App Router):
   - Har folder ek route hai
   - page.tsx = Page component
   - layout.tsx = Layout component
   - Special files: loading.tsx, error.tsx, not-found.tsx

3.3 page.tsx - Home Page:
   
   export default function Home() {
     return (
       <main>
         <h1>Welcome to Next.js</h1>
         <p>Start editing to see magic!</p>
       </main>
     );
   }
   
   Output:
   - Browser: http://localhost:3000
   - Renders: Welcome to Next.js

3.4 layout.tsx - Root Layout:
   
   export default function RootLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <html lang="en">
         <body>{children}</body>
       </html>
     );
   }
   
   - Har page mein include hota hai
   - HTML structure define karta hai

3.5 Special Files in app/:
   - page.tsx → Page UI
   - layout.tsx → Shared UI
   - loading.tsx → Loading state
   - error.tsx → Error boundary
   - not-found.tsx → 404 page
   - template.tsx → Re-rendered layout

3.6 public/ Directory:
   - Static assets yahan rakhein
   - Images, fonts, files
   - Direct URL se access: /image.png

3.7 Best Practices:
   ✓ app/ mein routes organize karein
   ✓ Components ko alag folder mein rakhein
   ✓ Public assets ko public/ mein rakhein
   ✓ TypeScript use karein type safety ke liye

✓ Project Structure Complete!

============================================================
CHAPTER 4: FILE-BASED ROUTING
============================================================

4.1 File-based Routing Kya Hai?
   Next.js mein folders aur files se routes automatically bante hain.
   No manual routing configuration needed!

4.2 Basic Routes:
   
   app/
   ├── page.tsx           → / (Home)
   ├── about/
   │   └── page.tsx       → /about
   ├── contact/
   │   └── page.tsx       → /contact
   └── blog/
       └── page.tsx       → /blog

4.3 Creating Routes - Examples:
   
   Example 1: About Page
   File: app/about/page.tsx
   URL: http://localhost:3000/about
   
   export default function About() {
     return <h1>About Page</h1>;
   }

   Example 2: Contact Page
   File: app/contact/page.tsx
   URL: http://localhost:3000/contact
   
   export default function Contact() {
     return <h1>Contact Page</h1>;
   }

4.4 Nested Routes:
   
   app/
   ├── blog/
   │   ├── page.tsx       → /blog
   │   └── post/
   │       └── page.tsx   → /blog/post

4.5 Multiple Routes Example:
   
   app/
   ├── page.tsx           → /
   ├── products/
   │   └── page.tsx       → /products
   ├── products/
   │   └── [id]/
   │       └── page.tsx   → /products/1
   ├── dashboard/
   │   └── page.tsx       → /dashboard
   └── settings/
       └── page.tsx       → /settings

4.6 Route Naming Conventions:
   ✓ Lowercase use karein
   ✓ Hyphens for spaces: about-us
   ✓ Singular or consistent naming
   ✗ Capital letters avoid karein
   ✗ Spaces use na karein

4.7 Testing Routes:
   - Dev server run karein: npm run dev
   - Browser mein URL type karein
   - Hot reload automatically update karega

✓ File-based Routing Complete!

============================================================
CHAPTER 5: LINK COMPONENT & NAVIGATION
============================================================

5.1 Link Component Kyun Zaroori Hai?
   - <a> tag se page reload hota hai
   - <Link> client-side navigation karta hai
   - Fast aur smooth navigation
   - Next.js built-in optimization

5.2 Link Component Import:
   
   import Link from 'next/link';

5.3 Basic Link Usage:
   
   <Link href="/">Home</Link>
   <Link href="/about">About</Link>
   <Link href="/contact">Contact</Link>

5.4 Link with Styling:
   
   <Link 
     href="/about"
     className="text-blue-500 hover:underline"
   >
     About Us
   </Link>

5.5 Active Link Styling:
   
   'use client';
   import Link from 'next/link';
   import { usePathname } from 'next/navigation';

   export default function Navbar() {
     const pathname = usePathname();
     
     return (
       <nav>
         <Link 
           href="/"
           className={pathname === '/' ? 'active' : ''}
         >
           Home
         </Link>
       </nav>
     );
   }

5.6 Navigation Component Example:
   
   'use client';
   import Link from 'next/link';

   export default function Navbar() {
     return (
       <nav className="flex gap-4 p-4">
         <Link href="/" className="hover:text-blue-500">
           Home
         </Link>
         <Link href="/products" className="hover:text-blue-500">
           Products
         </Link>
         <Link href="/about" className="hover:text-blue-500">
           About
         </Link>
         <Link href="/contact" className="hover:text-blue-500">
           Contact
         </Link>
       </nav>
     );
   }

5.7 Link Props:
   - href: URL (required)
   - className: CSS classes
   - prefetch: Boolean (default true)
   - replace: Boolean (history replace)
   - scroll: Boolean (scroll to top)

5.8 Programmatic Navigation:
   
   'use client';
   import { useRouter } from 'next/navigation';

   export default function Button() {
     const router = useRouter();
     
     const handleClick = () => {
       router.push('/dashboard');
     };
     
     return <button onClick={handleClick}>Go</button>;
   }

5.9 useRouter Methods:
   - router.push('/path) → Navigate
   - router.replace('/path) → Replace history
   - router.back() → Go back
   - router.forward() → Go forward
   - router.refresh() → Refresh

5.10 Best Practices:
   ✓ Link use karein for navigation
   ✓ Descriptive link text dein
   ✓ Active states show karein
   ✓ Mobile navigation consider karein

✓ Link Component & Navigation Complete!

============================================================
CHAPTER 6: LAYOUTS (root, nested layouts)
============================================================

6.1 Layouts Kyun Zaroori Hain?
   - Shared UI components (navbar, footer)
   - State preserve rehta hai
   - Re-rendering avoid hoti hai
   - Consistent design across pages

6.2 Root Layout (layout.tsx):
   
   app/layout.tsx
   
   export default function RootLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <html lang="en">
         <head>
           <title>My App</title>
           <meta name="description" content="My Next.js App" />
         </head>
         <body>
           {children}
         </body>
       </html>
     );
   }
   
   - Har page mein automatically include
   - Sirf ek root layout ho sakta hai

6.3 Nested Layouts:
   
   app/
   ├── layout.tsx         # Root: <html><body>
   ├── page.tsx           # Home
   └── dashboard/
       ├── layout.tsx     # Dashboard layout
       └── page.tsx       # Dashboard page

   app/dashboard/layout.tsx:
   
   export default function DashboardLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <div className="dashboard-layout">
         <Sidebar />
         <main>{children}</main>
         <Footer />
       </div>
     );
   }

6.4 Layout with Navbar & Footer:
   
   app/layout.tsx:
   
   import Navbar from '@/components/Navbar';
   import Footer from '@/components/Footer';

   export default function RootLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <html lang="en">
         <body>
           <Navbar />
           <main>{children}</main>
           <Footer />
         </body>
       </html>
     );
   }

6.5 Layout Composition:
   Root Layout (app/layout.tsx)
   └── Dashboard Layout (app/dashboard/layout.tsx)
       ├── Dashboard Page (app/dashboard/page.tsx)
       ├── Settings Page (app/dashboard/settings/page.tsx)
       └── Profile Page (app/dashboard/profile/page.tsx)

6.6 Layout Example with Styling:
   
   app/dashboard/layout.tsx:
   
   export default function DashboardLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <div className="flex h-screen">
         <aside className="w-64 bg-gray-800 text-white">
           <nav className="p-4">
             <Link href="/dashboard">Dashboard</Link>
             <Link href="/dashboard/settings">Settings</Link>
           </nav>
         </aside>
         <main className="flex-1 p-8">
           {children}
         </main>
       </div>
     );
   }

6.7 Layout Props:
   - children: React.ReactNode (required)
   - Har layout mein children render karna zaroori hai

6.8 Multiple Layouts Use Case:
   
   app/
   ├── layout.tsx         # Main site layout
   ├── page.tsx
   └── admin/
       ├── layout.tsx     # Admin layout (different)
       └── page.tsx

6.9 Best Practices:
   ✓ Root layout mein global providers rakhein
   ✓ Nested layouts for sections use karein
   ✓ Shared UI ko layouts mein rakhein
   ✓ Layouts ko simple rakhein

✓ Layouts Complete!

============================================================
CHAPTER 7: PAGE COMPONENT BASICS
============================================================

7.1 Page Component Kya Hai?
   - page.tsx = UI for a route
   - Default export karna zaroori hai
   - React component hota hai
   - Server Component by default

7.2 Basic Page Component:
   
   app/page.tsx:
   
   export default function Home() {
     return (
       <div>
         <h1>Welcome Home</h1>
         <p>This is the home page</p>
       </div>
     );
   }

7.3 Page with Props (Server Data):
   
   app/page.tsx:
   
   async function getData() {
     const res = await fetch('https://api.example.com/data');
     return res.json();
   }

   export default async function Home() {
     const data = await getData();
     
     return (
       <main>
         <h1>{data.title}</h1>
         <p>{data.description}</p>
       </main>
     );
   }

7.4 Page Metadata:
   
   app/page.tsx:
   
   export const metadata = {
     title: 'Home Page',
     description: 'Welcome to my website',
   };

   export default function Home() {
     return <h1>Home</h1>;
   }

7.5 Page with Loading State:
   
   app/page.tsx:
   
   import { Suspense } from 'react';

   export default function Page() {
     return (
       <Suspense fallback={<div>Loading...</div>}>
         <Content />
       </Suspense>
     );
   }

7.6 Page Variants:
   
   a) Static Page:
      export default function StaticPage() {
        return <h1>Static Content</h1>;
      }

   b) Dynamic Page:
      export default async function DynamicPage() {
        const data = await fetchData();
        return <h1>{data.title}</h1>;
      }

   c) Page with Params:
      app/[id]/page.tsx:
      export default async function Page({
        params
      }: {
        params: { id: string }
      }) {
        return <h1>Post: {params.id}</h1>;
      }

7.7 Page Component Rules:
   ✓ Default export zaroori hai
   ✓ Function component hona chahiye
   ✓ Server Component by default
   ✓ Async ho sakta hai
   ✓ Metadata export kar sakta hai

7.8 Common Page Patterns:
   
   Pattern 1: Simple Page
   export default function Simple() {
     return <div>Content</div>;
   }

   Pattern 2: Page with Sections
   export default function Page() {
     return (
       <>
         <Hero />
         <Features />
         <Testimonials />
         <CTA />
       </>
     );
   }

   Pattern 3: Page with Data
   export default async function Page() {
     const posts = await getPosts();
     return (
       <div>
         {posts.map(post => <Post key={post.id} {...post} />)}
       </div>
     );
   }

7.9 Best Practices:
   ✓ Page ko simple rakhein
   ✓ Logic ko components mein shift karein
   ✓ Loading states handle karein
   ✓ Error boundaries use karein
   ✓ SEO metadata add karein

✓ Page Component Basics Complete!

============================================================
CHAPTER 8: CLIENT VS SERVER COMPONENTS ('use client')
============================================================

8.1 Server Components (Default):
   - Default in Next.js App Router
   - Server pe render hote hain
   - Zero bundle size
   - Direct database/API access
   - SEO friendly

8.2 Client Components:
   - 'use client' directive se
   - Browser mein render hote hain
   - Interactivity ke liye
   - State aur effects use kar sakte hain
   - Browser APIs access kar sakte hain

8.3 'use client' Directive:
   
   'use client';
   import { useState } from 'react';

   export default function Counter() {
     const [count, setCount] = useState(0);
     return (
       <button onClick={() => setCount(count + 1)}>
         Count: {count}
       </button>
     );
   }

8.4 When to Use Server Components:
   ✓ Data fetch karna
   ✓ Database access
   ✓ Sensitive operations
   ✓ SEO important pages
   ✓ Static content

8.5 When to Use Client Components:
   ✓ State management (useState, useReducer)
   ✓ Event listeners (onClick, onChange)
   ✓ Browser APIs (localStorage, window)
   ✓ Custom hooks with state
   ✓ Third-party libraries with state

8.6 Server Component Example:
   
   app/page.tsx:
   
   // No 'use client' = Server Component
   async function getData() {
     const res = await fetch('https://api.example.com/data');
     return res.json();
   }

   export default async function Page() {
     const data = await getData();
     return <h1>{data.title}</h1>;
   }

8.7 Client Component Example:
   
   components/Counter.tsx:
   
   'use client';
   import { useState } from 'react';

   export default function Counter() {
     const [count, setCount] = useState(0);
     return (
       <button onClick={() => setCount(count + 1)}>
         Count: {count}
       </button>
     );
   }

8.8 Composition Pattern:
   
   app/page.tsx (Server):
   
   import Counter from '@/components/Counter';

   export default function Page() {
     const data = await fetchData();
     return (
       <div>
         <h1>{data.title}</h1>
         <Counter />  {/* Client Component */}
       </div>
     );
   }

8.9 Common Hooks (Client Only):
   - useState
   - useReducer
   - useEffect
   - useLayoutEffect
   - useRef (browser access)
   - usePathname
   - useRouter
   - useSearchParams

8.10 Props Passing (Server → Client):
   
   Server Component:
   
   import ClientComp from './ClientComp';

   export default async function ServerComp() {
     const data = await fetchData();
     return <ClientComp data={data} />;
   }

   Client Component:
   
   'use client';
   export default function ClientComp({ data }) {
     const [state, setState] = useState(data);
     return <div>{state}</div>;
   }

8.11 Best Practices:
   ✓ Server Components by default use karein
   ✓ Client Components sirf zaroorat pe use karein
   ✓ 'use client' file ke top pe likhein
   ✓ Client components ko isolate rakhein
   ✓ Props se data pass karein

✓ Client vs Server Components Complete!

============================================================
CHAPTER 9: STATIC & DYNAMIC RENDERING
============================================================

9.1 Static Rendering (Default):
   - Build time pe render hota hai
   - Fast delivery (CDN se)
   - SEO friendly
   - Same content for all users
   
   export default async function StaticPage() {
     const data = await fetchData();
     return <h1>{data.title}</h1>;
   }
   // Revalidates on build or with revalidate option

9.2 Dynamic Rendering:
   - Request time pe render hota hai
   - User-specific content
   - Real-time data
   
   'use client';
   export default function DynamicPage() {
     const [data, setData] = useState(null);
     useEffect(() => {
       fetchData().then(setData);
     }, []);
     return <h1>{data?.title}</h1>;
   }

9.3 Static Example:
   
   app/blog/[slug]/page.tsx:
   
   export default async function BlogPost({
     params
   }: {
     params: { slug: string }
   }) {
     const post = await fetch(`https://api.example.com/posts/${params.slug}`, {
       next: { revalidate: 3600 } // Revalidate every hour
     }).then(res => res.json());
     
     return (
       <article>
         <h1>{post.title}</h1>
         <p>{post.content}</p>
       </article>
     );
   }

9.4 Dynamic Example:
   
   app/dashboard/page.tsx:
   
   'use client';
   export default function Dashboard() {
     const [user, setUser] = useState(null);
     
     useEffect(() => {
       // Fetch user-specific data
       fetchUser().then(setUser);
     }, []);
     
     if (!user) return <div>Loading...</div>;
     
     return <h1>Welcome, {user.name}!</h1>;
   }

9.5 Revalidation Options:
   
   a) Time-based Revalidation:
      fetch(url, {
        next: { revalidate: 3600 } // 1 hour
      });

   b) On-demand Revalidation:
      import { revalidatePath } from 'next/cache';
      
      revalidatePath('/blog');

   c) Tag-based Revalidation:
      fetch(url, {
        next: { tags: ['posts'] }
      });
      revalidateTag('posts');

9.6 force-dynamic Option:
   
   app/dashboard/page.tsx:
   
   export const dynamic = 'force-dynamic';
   
   export default async function Dashboard() {
     // Always dynamic render
   }

9.7 Rendering Comparison:
   
   Static:
   - Build time render
   - CDN cached
   - Fast
   - Same for all users

   Dynamic:
   - Request time render
   - Server rendered
   - Slower
   - User-specific

9.8 Choosing Rendering Strategy:
   
   Static use karein jab:
   ✓ Blog posts
   ✓ Product pages
   ✓ Documentation
   ✓ Marketing pages

   Dynamic use karein jab:
   ✓ User dashboards
   ✓ Shopping carts
   ✓ Real-time data
   ✓ Personalized content

9.9 Best Practices:
   ✓ Static by default use karein
   ✓ Dynamic sirf zaroorat pe
   ✓ Revalidation strategy plan karein
   ✓ Cache headers set karein
   ✓ Loading states handle karein

✓ Static & Dynamic Rendering Complete!

============================================================
CHAPTER 10: LOADING UI & SUSPENSE
============================================================

10.1 Loading UI Kyun Zaroori Hai?
   - Better user experience
   - Perceived performance
   - Skeleton screens
   - Prevent layout shift

10.2 loading.tsx File:
   
   app/loading.tsx:
   
   export default function Loading() {
     return (
       <div className="flex items-center justify-center min-h-screen">
         <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
       </div>
     );
   }
   
   - Automatically show hota hai
   - Route changes pe
   - Data loading pe

10.3 Suspense Component:
   
   import { Suspense } from 'react';

   export default function Page() {
     return (
       <Suspense fallback={<div>Loading...</div>}>
         <Content />
       </Suspense>
     );
   }

10.4 Nested Suspense:
   
   export default function Page() {
     return (
       <Suspense fallback={<MainSkeleton />}>
         <Header />
         <Suspense fallback={<SidebarSkeleton />}>
           <Sidebar />
         </Suspense>
         <Suspense fallback={<ContentSkeleton />}>
           <Content />
         </Suspense>
       </Suspense>
     );
   }

10.5 Loading Skeleton Example:
   
   app/loading.tsx:
   
   export default function Loading() {
     return (
       <div className="space-y-4">
         <div className="h-8 bg-gray-200 rounded animate-pulse"></div>
         <div className="h-4 bg-gray-200 rounded animate-pulse"></div>
         <div className="h-4 bg-gray-200 rounded animate-pulse w-3/4"></div>
       </div>
     );
   }

10.6 Inline Loading:
   
   async function Content() {
     const data = await fetchData();
     return <div>{data}</div>;
   }

   export default function Page() {
     return (
       <Suspense fallback={<Spinner />}>
         <Content />
       </Suspense>
     );
   }

10.7 use Hook (Client Loading):
   
   'use client';
   import { use } from 'react';

   function Content({ promise }: { promise: Promise<any> }) {
     const data = use(promise);
     return <div>{data.title}</div>;
   }

10.8 Streaming with Suspense:
   
   export default async function Page() {
     return (
       <Suspense fallback={<Loading />}>
         <SlowComponent />
       </Suspense>
     );
   }

10.9 Best Practices:
   ✓ Meaningful loading states dein
   ✓ Skeleton screens use karein
   ✓ Progressive loading implement karein
   ✓ Loading time minimize karein
   ✓ Error states handle karein

✓ Loading UI & Suspense Complete!

============================================================
CHAPTER 11: IMAGES (Next/Image)
============================================================

11.1 Next/Image Kyun Zaroori Hai?
   - Automatic optimization
   - Lazy loading
   - Responsive images
   - Format optimization (WebP, AVIF)
   - Prevent layout shift

11.2 Image Component Import:
   
   import Image from 'next/image';

11.3 Basic Image Usage:
   
   <Image
     src="/hero.png"
     alt="Hero Image"
     width={500}
     height={300}
   />

11.4 Image Props:
   - src: Image source (required)
   - alt: Alt text (required for accessibility)
   - width: Width in pixels
   - height: Height in pixels
   - className: CSS classes
   - priority: Preload important images
   - quality: Image quality (1-100)
   - sizes: Responsive sizes

11.5 Responsive Images:
   
   <Image
     src="/hero.png"
     alt="Hero"
     width={1920}
     height={1080}
     sizes="100vw"
     style={{ width: '100%', height: 'auto' }}
   />

11.6 Fill Layout:
   
   <div className="relative h-64">
     <Image
       src="/hero.png"
       alt="Hero"
       fill
       className="object-cover"
     />
   </div>

11.7 Remote Images:
   
   next.config.mjs:
   
   const nextConfig = {
     images: {
       remotePatterns: [
         {
           protocol: 'https',
           hostname: 'images.example.com',
         },
       ],
     },
   };

   Usage:
   <Image
     src="https://images.example.com/photo.jpg"
     alt="Remote"
     width={400}
     height={300}
   />

11.8 Image Optimization:
   
   <Image
     src="/photo.jpg"
     alt="Photo"
     width={800}
     height={600}
     quality={75}
     priority
   />

11.9 Local vs Remote Images:
   
   Local (public/ folder):
   <Image src="/logo.png" alt="Logo" width={100} height={100} />

   Remote (External URL):
   - Config mein remotePatterns add karein
   - Then use kar sakte hain

11.10 Best Practices:
   ✓ Always provide alt text
   ✓ Correct dimensions use karein
   ✓ priority for above-fold images
   ✓ WebP format prefer karein
   ✓ Lazy loading enable rakhein

✓ Images (Next/Image) Complete!

============================================================
CHAPTER 12: ERROR HANDLING (error.tsx)
============================================================

12.1 Error Handling Kyun Zaroori Hai?
   - Better user experience
   - Graceful degradation
   - Debug information
   - App stability

12.2 error.tsx File:
   
   app/error.tsx:
   
   'use client';
   import { useEffect } from 'react';

   export default function Error({
     error,
     reset,
   }: {
     error: Error;
     reset: () => void;
   }) {
     useEffect(() => {
       console.error(error);
     }, [error]);

     return (
       <div className="flex flex-col items-center justify-center min-h-screen">
         <h2 className="text-2xl font-bold">Something went wrong!</h2>
         <button
           onClick={reset}
           className="mt-4 px-4 py-2 bg-blue-500 text-white rounded"
         >
           Try again
         </button>
       </div>
     );
   }

12.3 global-error.tsx (Root Error):
   
   app/global-error.tsx:
   
   'use client';
   export default function GlobalError({
     error,
     reset,
   }: {
     error: Error;
     reset: () => void;
   }) {
     return (
       <html>
         <body>
           <h2>Global Error!</h2>
           <button onClick={reset}>Try again</button>
         </body>
       </html>
     );
   }

12.4 Error Boundaries in Components:
   
   'use client';
   import { useState } from 'react';

   export default function Component() {
     const [error, setError] = useState<Error | null>(null);

     if (error) {
       return (
         <div>
           <h3>Error occurred</h3>
           <p>{error.message}</p>
         </div>
       );
     }

     return <div>Content</div>;
   }

12.5 Try-Catch in Server Components:
   
   export default async function Page() {
     try {
       const data = await fetchData();
       return <div>{data.title}</div>;
     } catch (error) {
       return <div>Failed to load data</div>;
     }
   }

12.6 not-found.tsx:
   
   app/not-found.tsx:
   
   import Link from 'next/link';

   export default function NotFound() {
     return (
       <div className="flex flex-col items-center justify-center min-h-screen">
         <h1 className="text-4xl font-bold">404</h1>
         <p className="mt-4">Page not found</p>
         <Link href="/" className="mt-4 text-blue-500">
           Go Home
         </Link>
       </div>
     );
   }

12.7 Programmatic 404:
   
   import { notFound } from 'next/navigation';

   export default async function Page({
     params
   }: {
     params: { id: string }
   }) {
     const data = await fetchData(params.id);
     
     if (!data) {
       notFound();
     }
     
     return <div>{data.title}</div>;
   }

12.8 Error Types:
   - 404: Page not found
   - 500: Server error
   - 400: Bad request
   - 401: Unauthorized
   - 403: Forbidden

12.9 Best Practices:
   ✓ User-friendly error messages
   ✓ Retry option provide karein
   ✓ Error logging implement karein
   ✓ Graceful fallbacks dein
   ✓ Error boundaries use karein

✓ Error Handling Complete!

============================================================
CHAPTER 13: STYLING (CSS Modules, Tailwind)
============================================================

13.1 CSS Modules:
   
   components/Button.module.css:
   
   .button {
     padding: 10px 20px;
     background: blue;
     color: white;
     border: none;
     border-radius: 4px;
   }

   components/Button.tsx:
   
   import styles from './Button.module.css';

   export default function Button() {
     return <button className={styles.button}>Click</button>;
   }

13.2 Tailwind CSS (Default in Next.js):
   
   app/page.tsx:
   
   export default function Home() {
     return (
       <div className="flex items-center justify-center min-h-screen">
         <h1 className="text-4xl font-bold text-blue-500">
           Hello World
         </h1>
       </div>
     );
   }

13.3 Global CSS:
   
   app/globals.css:
   
   @tailwind base;
   @tailwind components;
   @tailwind utilities;

   body {
     font-family: Arial, sans-serif;
   }

13.4 CSS Modules vs Tailwind:
   
   CSS Modules:
   ✓ Scoped styles
   ✓ Traditional CSS syntax
   ✓ Dynamic class names

   Tailwind:
   ✓ Utility-first
   ✓ Fast development
   ✓ Small bundle size
   ✓ Consistent design

13.5 Styled JSX (Built-in):
   
   export default function Page() {
     return (
       <div>
         <h1>Styled Heading</h1>
         <style jsx>{`
           h1 {
             color: blue;
             font-size: 2rem;
           }
         `}</style>
       </div>
     );
   }

13.6 Third-party Libraries:
   
   a) Styled Components:
      npm install styled-components
      
      import styled from 'styled-components';
      const Button = styled.button`
        padding: 10px 20px;
        background: blue;
      `;

   b) Emotion:
      npm install @emotion/react
      
      import { css } from '@emotion/react';
      <div css={css`color: blue;`}>Content</div>

13.7 Tailwind Config:
   
   tailwind.config.ts:
   
   import type { Config } from 'tailwindcss';

   const config: Config = {
     content: [
       './pages/**/*.{js,ts,jsx,tsx,mdx}',
       './components/**/*.{js,ts,jsx,tsx,mdx}',
       './app/**/*.{js,ts,jsx,tsx,mdx}',
     ],
     theme: {
       extend: {
         colors: {
           primary: '#0070f3',
         },
       },
     },
     plugins: [],
   };

   export default config;

13.8 Responsive Styling:
   
   <div className="
     text-sm
     md:text-base
     lg:text-lg
     xl:text-xl
   ">
     Responsive Text
   </div>

13.9 Dark Mode:
   
   tailwind.config.ts:
   
   const config: Config = {
     darkMode: 'class',
   };

   Usage:
   <div className="bg-white dark:bg-gray-800">
     Content
   </div>

13.10 Best Practices:
   ✓ Tailwind for rapid development
   ✓ CSS Modules for complex components
   ✓ Consistent naming conventions
   ✓ Mobile-first approach
   ✓ Dark mode support

✓ Styling Complete!

============================================================
CHAPTER 14: DATA FETCHING (fetch in Server Components)
============================================================

14.1 fetch in Server Components:
   
   app/page.tsx:
   
   export default async function Page() {
     const res = await fetch('https://api.example.com/data');
     const data = await res.json();
     
     return <h1>{data.title}</h1>;
   }

14.2 fetch Options:
   
   a) Static (Default):
      fetch(url);

   b) Dynamic:
      fetch(url, { cache: 'no-store' });

   c) Time-based Revalidation:
      fetch(url, { next: { revalidate: 3600 } });

   d) Tag-based Revalidation:
      fetch(url, { next: { tags: ['posts'] } });

14.3 Parallel Data Fetching:
   
   export default async function Page() {
     const [posts, users, comments] = await Promise.all([
       fetch('https://api.example.com/posts').then(r => r.json()),
       fetch('https://api.example.com/users').then(r => r.json()),
       fetch('https://api.example.com/comments').then(r => r.json()),
     ]);
     
     return <div>Content</div>;
   }

14.4 Sequential Data Fetching:
   
   export default async function Page() {
     const posts = await fetch('https://api.example.com/posts')
       .then(r => r.json());
     
     const comments = await fetch(
       `https://api.example.com/posts/${posts[0].id}/comments`
     ).then(r => r.json());
     
     return <div>Content</div>;
   }

14.5 Error Handling:
   
   export default async function Page() {
     try {
       const res = await fetch('https://api.example.com/data');
       if (!res.ok) throw new Error('Failed to fetch');
       const data = await res.json();
       return <div>{data.title}</div>;
     } catch (error) {
       return <div>Error loading data</div>;
     }
   }

14.6 Fetch with Headers:
   
   const res = await fetch('https://api.example.com/data', {
     headers: {
       'Authorization': 'Bearer token',
       'Content-Type': 'application/json',
     },
   });

14.7 POST Request:
   
   async function createPost(data: any) {
     const res = await fetch('https://api.example.com/posts', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify(data),
     });
     return res.json();
   }

14.8 Best Practices:
   ✓ Server Components mein fetch karein
   ✓ Error handling implement karein
   ✓ Parallel fetching for independent data
   ✓ Cache strategy set karein
   ✓ Loading states handle karein

✓ Data Fetching Complete!

============================================================
CHAPTER 15: SERVER ACTIONS
============================================================

15.1 Server Actions Kya Hain?
   - Server-side functions
   - Client components se call kar sakte hain
   - Form submissions ke liye
   - Mutations ke liye
   - Type-safe

15.2 Basic Server Action:
   
   app/actions.ts:
   
   'use server';

   export async function createPost(formData: FormData) {
     const title = formData.get('title') as string;
     const content = formData.get('content') as string;
     
     // Database operation
     await db.post.create({ title, content });
     
     return { success: true };
   }

15.3 Server Action with Form:
   
   'use client';
   import { createPost } from './actions';

   export default function Form() {
     return (
       <form action={createPost}>
         <input name="title" type="text" />
         <textarea name="content" />
         <button type="submit">Create Post</button>
       </form>
     );
   }

15.4 useFormStatus Hook:
   
   'use client';
   import { useFormStatus } from 'react-dom';

   function SubmitButton() {
     const { pending } = useFormStatus();
     
     return (
       <button type="submit" disabled={pending}>
         {pending ? 'Submitting...' : 'Submit'}
       </button>
     );
   }

15.5 useActionState Hook:
   
   'use client';
   import { useActionState } from 'react';
   import { createPost } from './actions';

   export default function Form() {
     const [state, formAction] = useActionState(createPost, null);
     
     return (
       <form action={formAction}>
         <input name="title" />
         <button type="submit">Submit</button>
         {state?.error && <p>{state.error}</p>}
       </form>
     );
   }

15.6 Server Action with Validation:
   
   'use server';
   export async function createUser(formData: FormData) {
     const email = formData.get('email') as string;
     
     if (!email || !email.includes('@')) {
       return { error: 'Invalid email' };
     }
     
     await db.user.create({ email });
     return { success: true };
   }

15.7 Revalidate After Mutation:
   
   'use server';
   import { revalidatePath } from 'next/cache';

   export async function updatePost(formData: FormData) {
     await db.post.update({ ... });
     revalidatePath('/posts');
   }

15.8 Server Action in Route Handler:
   
   app/api/posts/route.ts:
   
   export async function POST(request: Request) {
     const body = await request.json();
     // Process
     return Response.json({ success: true });
   }

15.9 Best Practices:
   ✓ 'use server' directive use karein
   ✓ Input validation karein
   ✓ Error handling implement karein
   ✓ Loading states show karein
   ✓ Revalidation handle karein

✓ Server Actions Complete!

============================================================
CHAPTER 16: FORMS (useFormStatus, useActionState)
============================================================

16.1 Basic Form:
   
   export default function ContactForm() {
     return (
       <form>
         <input type="text" name="name" placeholder="Name" />
         <input type="email" name="email" placeholder="Email" />
         <textarea name="message" placeholder="Message" />
         <button type="submit">Send</button>
       </form>
     );
   }

16.2 Form with Server Action:
   
   'use server';
   async function submitForm(formData: FormData) {
     'use server';
     const name = formData.get('name');
     // Process
   }

   export default function Form() {
     return <form action={submitForm}>...</form>;
   }

16.3 useFormStatus:
   
   'use client';
   import { useFormStatus } from 'react-dom';

   function Status() {
     const { pending, data, method, action } = useFormStatus();
     
     return (
       <div>
         {pending && <p>Submitting...</p>}
       </div>
     );
   }

16.4 useActionState:
   
   'use client';
   import { useActionState } from 'react';

   const initialState = { message: null };

   function formAction(state: any, formData: FormData) {
     return { message: 'Submitted!' };
   }

   export default function Form() {
     const [state, formAction] = useActionState(formAction, initialState);
     
     return (
       <form action={formAction}>
         <input name="email" />
         <button type="submit">Submit</button>
         <p>{state.message}</p>
       </form>
     );
   }

16.5 Form Validation:
   
   'use server';
   export async function registerUser(formData: FormData) {
     const email = formData.get('email') as string;
     const password = formData.get('password') as string;
     
     const errors = [];
     
     if (!email) errors.push('Email required');
     if (password.length < 8) errors.push('Password too short');
     
     if (errors.length > 0) {
       return { errors };
     }
     
     // Create user
     return { success: true };
   }

16.6 Form with Error Display:
   
   'use client';
   import { useActionState } from 'react';

   export default function RegisterForm() {
     const [state, formAction] = useActionState(registerUser, null);
     
     return (
       <form action={formAction}>
         <input name="email" />
         <input name="password" type="password" />
         {state?.errors?.map((err: string) => (
           <p key={err} className="text-red-500">{err}</p>
         ))}
         <button type="submit">Register</button>
       </form>
     );
   }

16.7 Optimistic Updates:
   
   'use client';
   import { useOptimistic } from 'react';

   export default function TodoList({ todos }: { todos: Todo[] }) {
     const [optimisticTodos, addOptimisticTodo] = useOptimistic(
       todos,
       (state, newTodo: Todo) => [...state, newTodo]
     );
     
     return (
       <ul>
         {optimisticTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}
       </ul>
     );
   }

16.8 Best Practices:
   ✓ Server-side validation karein
   ✓ Client-side validation bhi karein
   ✓ Loading states show karein
   ✓ Error messages display karein
   ✓ Success feedback dein

✓ Forms Complete!

============================================================
CHAPTER 17: METADATA API (title, description)
============================================================

17.1 Metadata API Kya Hai?
   - SEO ke liye
   - Social media cards
   - Page title, description
   - Open Graph tags
   - Twitter cards

17.2 Static Metadata:
   
   app/page.tsx:
   
   export const metadata = {
     title: 'Home Page',
     description: 'Welcome to my website',
     keywords: ['nextjs', 'react', 'web'],
     authors: [{ name: 'John Doe' }],
   };

17.3 Dynamic Metadata:
   
   app/blog/[slug]/page.tsx:
   
   export async function generateMetadata({
     params
   }: {
     params: { slug: string }
   }) {
     const post = await getPost(params.slug);
     
     return {
       title: post.title,
       description: post.excerpt,
     };
   }

17.4 Open Graph (Social Sharing):
   
   export const metadata = {
     title: 'My Page',
     description: 'Page description',
     openGraph: {
       title: 'My Page',
       description: 'Page description',
       images: ['/og-image.jpg'],
       url: 'https://example.com',
       type: 'website',
     },
   };

17.5 Twitter Cards:
   
   export const metadata = {
     twitter: {
       card: 'summary_large_image',
       title: 'My Page',
       description: 'Description',
       images: ['/twitter-image.jpg'],
       creator: '@username',
     },
   };

17.6 Metadata in Layout:
   
   app/layout.tsx:
   
   export const metadata = {
     title: {
       default: 'My App',
       template: '%s | My App',
     },
     description: 'My awesome app',
   };

17.7 Metadata Fields:
   - title: Page title
   - description: Page description
   - keywords: SEO keywords
   - authors: Author information
   - robots: Crawler directives
   - openGraph: Social sharing
   - twitter: Twitter cards
   - icons: Favicon
   - manifest: Web app manifest

17.8 Viewport Metadata:
   
   export const viewport = {
     width: 'device-width',
     initialScale: 1,
     maximumScale: 1,
   };

17.9 Icons:
   
   export const metadata = {
     icons: {
       icon: '/favicon.ico',
       apple: '/apple-touch-icon.png',
     },
   };

17.10 Best Practices:
   ✓ Unique title for each page
   ✓ Descriptive description (150-160 chars)
   ✓ Open Graph for social sharing
   ✓ Relevant keywords
   ✓ Proper favicon

✓ Metadata API Complete!

============================================================
CHAPTER 18: BASIC CODING PROJECT
============================================================

18.1 Project: Personal Portfolio Website
   
   Features:
   - Home page with introduction
   - About page
   - Projects page
   - Contact form
   - Responsive design
   - Dark mode

18.2 Project Setup:
   
   npx create-next-app@latest portfolio
   cd portfolio
   npm run dev

18.3 Project Structure:
   
   app/
   ├── layout.tsx
   ├── page.tsx              # Home
   ├── about/
   │   └── page.tsx
   ├── projects/
   │   └── page.tsx
   ├── contact/
   │   └── page.tsx
   └── globals.css

18.4 Home Page (app/page.tsx):
   
   import Link from 'next/link';

   export default function Home() {
     return (
       <main className="min-h-screen p-8">
         <h1 className="text-4xl font-bold">Hi, I'm John</h1>
         <p className="mt-4 text-xl">Full Stack Developer</p>
         <nav className="mt-8 flex gap-4">
           <Link href="/about" className="text-blue-500">About</Link>
           <Link href="/projects" className="text-blue-500">Projects</Link>
           <Link href="/contact" className="text-blue-500">Contact</Link>
         </nav>
       </main>
     );
   }

18.5 About Page (app/about/page.tsx):
   
   export const metadata = {
     title: 'About Me',
   };

   export default function About() {
     return (
       <div className="min-h-screen p-8">
         <h1 className="text-3xl font-bold">About Me</h1>
         <p className="mt-4">
           I'm a passionate developer with 5 years of experience.
         </p>
       </div>
     );
   }

18.6 Projects Page (app/projects/page.tsx):
   
   const projects = [
     { id: 1, title: 'Project 1', description: 'Description 1' },
     { id: 2, title: 'Project 2', description: 'Description 2' },
   ];

   export default function Projects() {
     return (
       <div className="min-h-screen p-8">
         <h1 className="text-3xl font-bold">Projects</h1>
         <div className="mt-8 grid gap-4">
           {projects.map(project => (
             <div key={project.id} className="border p-4 rounded">
               <h2 className="text-xl">{project.title}</h2>
               <p>{project.description}</p>
             </div>
           ))}
         </div>
       </div>
     );
   }

18.7 Contact Page with Form (app/contact/page.tsx):
   
   'use server';
   async function submitForm(formData: FormData) {
     'use server';
     const email = formData.get('email');
     const message = formData.get('message');
     // Send email logic
     console.log(email, message);
   }

   export default function Contact() {
     return (
       <div className="min-h-screen p-8">
         <h1 className="text-3xl font-bold">Contact</h1>
         <form action={submitForm} className="mt-8 space-y-4">
           <input
             name="email"
             type="email"
             placeholder="Your Email"
             className="w-full p-2 border rounded"
           />
           <textarea
             name="message"
             placeholder="Your Message"
             className="w-full p-2 border rounded"
           />
           <button
             type="submit"
             className="px-4 py-2 bg-blue-500 text-white rounded"
           >
             Send Message
           </button>
         </form>
       </div>
     );
   }

18.8 Layout with Navbar (app/layout.tsx):
   
   import './globals.css';
   import Link from 'next/link';

   export const metadata = {
     title: 'John Doe - Portfolio',
     description: 'Full Stack Developer Portfolio',
   };

   export default function RootLayout({
     children,
   }: {
     children: React.ReactNode;
   }) {
     return (
       <html lang="en">
         <body>
           <nav className="p-4 bg-gray-800 text-white">
             <Link href="/" className="mr-4">Home</Link>
             <Link href="/about" className="mr-4">About</Link>
             <Link href="/projects" className="mr-4">Projects</Link>
             <Link href="/contact" className="mr-4">Contact</Link>
           </nav>
           {children}
         </body>
       </html>
     );
   }

18.9 Dark Mode Toggle (Optional):
   
   'use client';
   import { useTheme } from 'next-themes';

   export default function ThemeToggle() {
     const { theme, setTheme } = useTheme();
     
     return (
       <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>
         Toggle Theme
       </button>
     );
   }

18.10 Deployment:
   
   a) Vercel (Recommended):
      - Push to GitHub
      - Import on Vercel
      - Deploy automatically

   b) Static Export:
      next.config.mjs:
      const nextConfig = { output: 'export' };
      
      npm run build
      // Output in out/ folder

✓ Basic Coding Project Complete!

============================================================
   NEXT.JS BASIC COURSE - COMPLETE!
============================================================

✓ All 18 Chapters Covered!
✓ Ready for Advanced Course!
